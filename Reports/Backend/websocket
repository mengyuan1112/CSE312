Open-source websocket library Report:

Library used:
javax.websocket(CDDL 1.1 GPL 2.0)
org.springframework(Apache)

Related files in project:

File: src/main/java/cse312/demo/Configuration/wsConfig.java
This file is for configure the websocket to be functional by using the ServerEndpointExporter class detects beans of type ServerEndpointConfig and registers with the standard Java websocket runtime.
Source Code: https://github.com/spring-projects/spring-framework/blob/master/spring-websocket/src/main/java/org/springframework/web/socket/server/standard/ServerEndpointExporter.java

File: src/main/java/cse312/demo/Service/ChatService.java
Set annotation @Service for the User service class which relate to the User Repository then it is able to automatically pair with DB without create something, use Autowire annotation with it,
it will auto build object db for us. The purpose of this class is to help connect the Data, Model with Restful API. We use service class to call the method or data from the original,
it will help us to change the requirements and maintain the structure in the future.


File: src/main/java/cse312/demo/APIController/chatController.java
This file used javax.websocket package in tomcat-embed-websocket (org.apache.tomcat.websocket) which is JSR 346 (under RFC6455 protocol) defines Java API for creating websocket.
For establish WebSocket which is a two-way communication application layer protocol based on TCP. The Endpoint class is used to implement WebSocket-related business logic and process WebSocket data frames.
The @ServerEndpoint marks the POJO as a WebSocket server endpoint. URI of the deployed endpoint is as a text value which invoked whenever a message with text payload is received by this endpoint.
Payload of the message is mapped to the parameter in PojoEndpointBase class (https://github.com/apache/tomcat/blob/master/java/org/apache/tomcat/websocket/pojo/PojoEndpointBase.java) 
which in the source code is called pathParameters. The method doOnOpen get two type of parameters: Session(involve a series of websocket operation method) and EndpointConfig(involve getEncoders(), getDecoders()).
By ensuring the onOpen from the listening URL is not null, do the series of oepration to decode message from the websocket frame by using the corresponding method in Seesion class, MessageHandler class and EndpointConfig class.
If there is not an onOpen status from the listening URL, then catch it as a OnError status and close the session as the method handleOnOpenOrCloseError() do.
For onClose method, same idea as the onOpen, check the parameter got from the ServerEndpoint and see if it is onClose status, then close the session. (same idea with the onError method).
Note: All the operaton on the onOpen, onClose, onError are in the PojoMethodMapping class(https://github.com/apache/tomcat/blob/master/java/org/apache/tomcat/websocket/pojo/PojoMethodMapping.java)

Handshake:
For establishing the websocket handshake, by using the API class WsWebSocketContainer(https://github.com/apache/tomcat/blob/master/java/org/apache/tomcat/websocket/WsWebSocketContainer.java). The class contains a
series of fundamental method: parseStatus(parsing the http status), parseHeader(parsing the http request header), readLine(convert the ByteBuffer to string in line), etc. The subclass HttpResponse contain the HandshakeResponse
varible which the API get it by WsHandshakeResponse class(https://github.com/apache/tomcat/blob/master/java/org/apache/tomcat/websocket/WsHandshakeResponse.java). In this class, it read the key in the request header and encode
it by using CaseInsensitiveKeyMap class(https://github.com/apache/tomcat/blob/master/java/org/apache/tomcat/util/collections/CaseInsensitiveKeyMap.java),


Parse websocket frame:
Most of the important method for the process the websocket frame is in WsFrameBase class(https://github.com/apache/tomcat/blob/master/java/org/apache/tomcat/websocket/WsFrameBase.java)

Send websocket data frame:
By using the feature in Session, which can do all the operation with the websocket data.
For send text, we use RemoteEndpoint.Basic getBasicRemote() to send websocket data frame to the client, which we have the choice that use sendText() to send string type message with opcode 0x1,
and sendBinary() to send data in bytes with opcode(0x2). RemoteEndpoint send data by the Encoder class which can encode Binary or Text.

Receive and process websocket data frame:
When the web container receives a data frame, because the Endpoint has been determined during the handshake phase,
it only needs to determine whether it is binary data or character data according to the opcode field of the WebSocket data frame. The former uses Decoder. Binary to implement the class. The latter uses Decoder.
Text to implement the class. After parsing into a Java object, send it like discussed before in the method modified by @OnMessage.



